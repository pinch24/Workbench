[GraphQL in Action by Same Buna, 2021]()

# Part 1. GraphQL 경험해보기
GraphQL은 API 사용자가 데이터를 요청할 때 사용하는 언어다.

# Chapter 1. GraphQL 소개
**커뮤니케이션**은 아주 어려운 기술이다. 커뮤니케이션 능력을 키우면 다양한 방면에서 삶이 더 윤택해진다. 마찬가지로 소프트웨어의 각기 다른 부분 간에 발생하는 커뮤니케이션의 품질을 향상시키면 해당 **소프트웨어를 이해하기 쉬워질 뿐만 아니라, 개발, 유지관리, 확장도 쉬워진다.**

GraphQL은 프론트엔드와 백엔드에 동등한 힘을 싫어주면서, 서로 독립할 수 있게 해준다. 또한, 둘 사이의 커뮤니케이션 프로세스를 기술적 전송 채널에서 분리해주며, 말로는 한정된 단어밖에 사용할 수 없는 일반 커뮤니케이션 언어를 대체하도록 표현력이 풍부한 언어를 제공한다.

## 1.1 GraphQL이란?
GraphQL의 Graph는 현실 세계의 데이터를 표현하는 가장 적합한 방법이 그래프라는 사실에서 착안했다. 이것이 필자가 감탄한 부분이다. 그래프로 생각하면 더 쉬운 것을 왜 굳이 URL과 같은 리소스나 테이블로 생각하는 것일까?

Backend에는 GraphQL 기반의 **런타임**이 필요하다. 이 런타임은 API를 통해 제공될 **데이터의 구조**를 관리한다. 이 구조를 GraphQL에서는 **Scheme**라고 부른다.
API 클라이언트는 GraphQL 언어를 사용해서 필요한 데이터를 정확하게 요구하기 위해 텍스트를 구성하고 클라이언트는 이 텍스트 요청을 HTTP와 같은 전송 채널을 통해 API 서비스에 전달한다. 그러면 GraphQL의 런타임 계층이 이 텍스트 요청을 받아서 백엔드에 있는 다른 서비스들과 커뮤니케이션하고 그 결과들을 모아서 적합한 데이터를 만든다. 그렇게 만들어진 데이터를 JSON 같은 형식으로 API 클라이언트에 반환한다.

### 1.1.1 GraphQL의 전체 구성
GraphQL은 프로그래밍 가능한 많은 인터페이스 중 하나로 애플리에키션이 필요로 하는 데이터를 읽고 수정할 수 있게 해준다. 이런 인터페이스에는 GraphQL 외에 REST, SOAP, XML 등이 있다.

SQL은 QL이라는 이름 때문에 GraphQL과 직접 비교 대상이 되기도 한다.
**SQL과 GraphQL** 모두 **데이터 스키마를 요청할 수 있는 언어**이며, 양쪽 모두 데이터를 읽고 수정할 수 있다. 그러나 SQL은 데이터 교환을 위해 클라이언트 애플리케이션에서 사용하기에 적합하지 않다. SQL 자체가 그런 용도로 사용하기 위한 것이 아니다. SQL은 강력하면서도 유연성이 높으므로 오히려 문제를 초래할 수도 있다. 예를 들면 **데이터베이스 구조를 노출**시켜서 심각한 보안 문제를 불러오기도 한다. 이런 문제를 보완하기 위해 SQL을 다른 서비스 계층에 둘 수 있지만, 사용자의 SQL 쿼리를 서버에 보내기 전에 처리할 수 있는 Parser 또는 Analyzer를 만들어야 한다. 이 역학을 대신하는 것이 GraphQL 서버이다.

JSON은 데이터 교환을 위해 사용되는 언어이다.
JSON은 GraphQL의 데이터 요구 사항을 만족시켜주는 일반적인 옵션 중 하나이다.

GraphQL은 클라이언트와 서버 간 데이터 교환을 최적화하기 위한 툴이다.

GrpahQL의 핵심은 데이터를 정의하고 API를 관리할 때 사용하는 강력한 **Type System** 이다. 이 타입 시스템은 클라이언트가 요청할 수 있는 데이터 타입을 명확하게 제시하고 잘못된 경우에는 자세하고 유용한 오류 메시지를 제공한다. 또한, 클라이언트는 타입을 사용해서 데이터 요소를 전달하기 위한 수작업을 최소화한다.

### 1.1.2 GraphQL은 사양이다

### 1.1.3 GraphQL은 언어다
GraphQL의 QL에는 Query라는 뜻이 있지만 이 단어는 읽는 행위를 의미한다. 그러나 GraphQL은 데이터를 읽기 뿐만 아니라 수정도 할 수 있다. 데이터를 읽을 때는 **Query**를 사용하고 수정할 때는 **Mutation**을 사용한다.

과거에는 컴퓨터가 명령한 것만 이해할 수 있었으므로 명령형 패러다임 Imperative Paradigm을 사용해서 프로그램을 만들었다. 하지만 현재 컴퓨터는 선언적 패러다임 Declarative Paradigm을 이해하기 시작했으며, 우리가 원하는 것을 이해하는 프로그램을 만들 수 있게 됐다. 선언적 프로그래밍이 의미가 있는 것은 사람이 어떤 문제의 원인을 생각할 때 선언적으로 접근한다는 것이다. 사람은 선언적으로 사고하는 데에 익숙하다.

### 1.1.4 GraphQL은 서비스다
GraphQL은 저장 엔진이 아니므로 그 자체를 DB 같은 서버로 사용할 수 없다. 따라서 런타임 계층으로 별도의 층을 만들어서 언어를 변환하는 것이다.

GraphQL 서비스는 원하는 프로그래밍 언어를 사용해서 구현할 수 있으며, 개념적으로 구조 **Structure**와 행동 **Behavior**으로 나뉜다.

- Structure: 강력한 타입의 **Scheme**를 사용해서 정의한다. 스키마는 타입을 가진 필드들을 그래프로 나타낸 것이며 이 그래프는 데이터 서비스를 통해 읽고 수정할 수 있는 모든 데이터 객체를 보여준다.
- Behavior: 함수를 통해 구현되며 **Resolver Function**이라고 부른다. 리졸버 함수는 GraphQL의 뒤에서 움직이는 대부분의 처리 로직으로 GraphQL 스키마의 각 필드는 리졸버 함수와 연동되며, 리졸버 함수에는 각 필드가 어떤 값을 가져와야 하는지 정의한다.

GraphQL은 특정 데이터 직렬화 Serialization 형식을 요구하진 않지만, JSON이 대중적으로 사용된다.

## 1.2 왜 GraphQL인가?
GraphQL은 관리와 확장이 용이한 API 기능을 광범위한 **표준**과 **구조**를 사용해서 **구현**할 수 있다. GraphQL에선 데이터 API의 기능 범위를 반드시 문서(스키마)를 통해 공개할 것을 규칙으로 정하고 있다. 클라이언트는 이 스키마를 통해 해당 서버 상에서 할 수 있는 모든 것을 파악할 수 있다.

GraphQL 스키마는 GraphQL 서비스가 할 수 있는 작업과 제한 사항을 알려준다. 또한, 스키마가 노드 구조의 그래프로 구성돼 있어서 다양한 경로를 만들 수 있으며, 이는 스키마에게 **유연성**을 부여한다. 이 유연성으로 백엔드와 프런트엔드 개발자가 서로 별도의 논의 없이도 각자 개발을 진행할 수 있도록 만든다. 클라이언트와 서버를 분리시켜서 각자 독립적으로 발전, 확장할 수 있게 해줘서 결과적으로는 양쪽 제품의 개발 주기가 단축된다.

클라이언트-서버 구조에서 GraphQL을 선택하는 가장 중요한 기술적 이유는 **효율성**이다.
API 클라이언트는 종종 서버에게 여러 리소스를 요청해야 하지만 API 서버는 보통 하나의 리소스만 응답하는 방법을 안다. 그래서 결과적으로 필요한 모든 데이터를 얻기 위해선 클라이언트가 서버에게 여러 번 요청하게 된다. GraphQL은 이런 **다중 요청의 복잡성을 백엔드에 부담시켜서 GraphQL 런타임이 처리**하도록 만든다. 클라이언트가 GraphQL 서비스로 하나의 질문을 던지면 서비스는 필요한 정보를 정확하게 하나의 응답으로 담아서 반환한다. (**REST 기반**의 API도 뷰당 하나의 엔드포인트를 통해 동일한 처리를 하게 만들 수 있지만 일반적인 방법은 아니다. **결국에는 표준 가이드에서 벗어난 방식으로 개발해야 한다.**)

GraphQL의 또 다른 기술적 이점은 여러 서비스와 커뮤니케이션 할 수 있다는 것이다. 클라이언트가 여러 데이터 저장소(ex. PostgreSQL, MongoDB, Redis Cache 등)로부터 데이터를 요청할 때, 중간에 있는 **GraphQL 계층이 커뮤니케이션을 단순화 및 표준화한다.** 클라이언트는 여러 서비스에 직접 접속하는 것이 아니라 GraphQL과 커뮤니케이션 하며, 요청을 받은 GraphQL 서비스가 여러 데이터 서비스와 커뮤니케이션 한다. GraphQL 서비스는 클라이언트 요청 하나를 다른 언어를 사용하는 서비스 요청 여러 개로 변환한다.

### 1.2.1 REST API와의 차이점
REST API가 가장 가장 큰 문제점은 클라이언트가 여러 개의 데이터 API 엔드포인트와 커뮤니케이션 한다는 것이다. REST API는 클라이언트가 데이터를 받기 위해서 네트워크를 여러번 왕복해야 한다. REST API는 리소스별로 엔드포인트를 가지므로 엔드포인트의 집합이라고 볼 수 있다. 따라서 **여러 리소스에서 데이터를 가져와야 한다면, REST API에 여러 개의 네트워크 요청을 던져야 하며, 응답 역시 마찬가지로 여러 개의 응답을 받아 결합해야 한다.**

Pure REST API를 사용하면 클라이언트가 리소스에서 레코드를 추출 할 때 특정 필드를 지정할 수 없다. 클라이언트가 필요로 하는 데이터와 상관없이 REST API 서비스는 항상 모든 필드를 반환한다. GraphQL에서는 이런 것을 **Overfetching**이라고 부르며 발생해서는 안 되는 문제로 간주한다. 이것은 클라이언트와 서버 양쪽의 네트워크 및 메모리 리소스를 낭비하는 것이다.

REST API의 또 다른 큰 문제는 버전 관리 **Versioning** 이다. 여러 버전을 제공해야 한다면, 엔드포인트도 여러 개 준비해야 한다는 의미다. 이것은 엔드포인트를 사용하고 관리할 때 더 문제가 되며 서버상의 코드 중복 문제도 초래할 수 있다.

### 1.2.2 GraphQL의 방식

#### 타입이 정해진 그래프 스키마
GraphQL API를 만들려면 타입이 정해진 스키마가 필요하다.

#### 선언적 언어
GraphQL 데이터 요건을 표현하기 위해 선언적 언어를 사용한다.

#### 단일 엔드포인트와 클라이언트 언어
여러 번 왕복해서 통신하는 문제를 해결하기 위해서 GraphQL은 응답하는 서버를 단일 엔드 포인트로 만든다.

#### 간단한 버전 관리
**GraphQL은 따로 버전 관리를 할 필요가 없다.** **그래프 구조**를 가지고 있기 때문에 기존 필드를 삭제할 필요 없이 새 필드를 새로운 노드로 추가만 하면 된다. 즉, 이전 버전의 API에서 GraphQL 경로를 유지한 채 새 경로와 노드를 추가하면 되는 것이다. 새 엔드포인트를 추가할 필요 없이 API만 확장된다. 클라이언트는 이전 기능들을 그대로 사용할 수 있으며 새 기능을 사용하려면 기존 코드에 변경된 부분만 추가하면 된다. **하나의 버전이 계속 확장 및 진화해 나가므로 클라이언트는 기존 및 새 기능들을 지속적으로 사용**할 수 있으며, 서버는 **간결하고 관리하기 쉬운 코드를 유지**할 수 있다.
그러나 이런 버전 관리 접근법에는 문제점도 있다. 그중 하나는 이전 노드를 계속 유지하기 쉽지 않다는 것이다. API 클라이언트 입장에선 어떤 노드가 새것이고 어떤 것이 오래된 것인지 구분하기 어려워 혼란스러울 수도 있다. 이를 위해서 GraphQL에선 오래된 노드를 폐지하거나 숨겨서 스키마 사용자가 새 노드만 보도록 하는 기능을 제공한다. 또한 GraphQL에선 필드가 얼마나 자주 사용되는지 알 수 있으므로 관리가 가능하다.

### 1.2.3 실행을 통한 REST API와 GraphQL API 비교
한 번의 네트워크 왕복만으로 필요한 데이터를 얻으려면, 복잡한 데이터 요건을 서버에게 전달 할 방법이 필요하다. 이때 필요한 것이 **GraphQL Query** 이다.

GraphQL Query로 질의를 던지면 JSON 포맷으로 결과를 응답 받을 수 있다. GraphQL 쿼리가 응답과 동일한 구조를 가지므로 쿼리만 보고서도 UI와 데이터를 어떻게 연결시켜야 하는지 알 수 있다. 즉, 데이터를 사용하기 위해서 응답을 볼 필요가 없으며 API 문서를 참고할 필요도 없는 것이다. 모든 정보가 쿼리에 이미 들어있기 때문이다.

## 1.3 GraphQL의 문제점
GraphQL이 가진 유연성이 때로는 문제의 원인이 되기도 한다.

### 1.3.1 보안
GraphQL API에 있어 DDos 공격은 큰 위협이 된다. 다중 중첩된 쿼리(User -\> Friend -\> Friend -\> Friend …)를 쉽게 요청할 수 있으며, 필드 별칭을 사용해서 동일 필드에 대한 정보를 여러 번 요청할 수도 있다.

GraphQL 클라이언트는 데이터 요청에 제약이 없다. 한 번에 아주 많은 데이터를 요청할 수도 있다.
이를 방지하기 위한 방법이 몇 가지 있다.
- 첫 번째는 쿼리의 효율성을 미리 분석해서 사용되는 데이터 양을 제한하는 방법이다. 
- 두 번째는 타임아웃을 설정해서 처리 시간이 오래 걸리는 요청을 정지시키는 것이다.
- 세 번째는 GraphQL 서비스가 애플리케이션 스택의 한 계층이란 점을 사용해 GraphQL 보다 낮은 계층에서 강제적으로 처리량을 제어하는 것이다.

GraphQL API의 엔드포인트가 외부에 공개되어있지 않고 클라이언트에서 내부적으로 사용한다면 허용 리스트(allow-list)를 만들어서 사전에 서버가 실행할 수 있는 쿼리를 지정해두는 방법이 있다. 이렇게 하면 클라이언트는 고유의 쿼리 식별자를 사용해서 서버에게 허용 목록에 있는 쿼리만 요청할 수 있다.

GraphQL은 인증이나 권한 관리 로직에 관여하지 않는다.

### 1.3.2 캐시와 최적화
GraphQL에서 어려운 것 중 하나가 데이터의 캐싱(Caching) 이다. REST API의 응답은 딕셔너리 구조이기 때문에 훨씬 캐시가 쉽다. 특정 URL이 정해진 데이터를 반환하므로 URL 자체를 캐시키로 사용할 수 있기 때문이다.

GraphQL은 쿼리 텍스트를 키로 사용해서 응답을 캐싱 할 수 있다. 하지만 이 방법은 비효율적이며 데이터 일관성 문제를 초래할 수 있다. 여러 개의 GraphQL 쿼리 결과는 쉽게 중복될 수 있으며, 이 기본 캐시 방법으로는 중복 데이터를 가려 낼 수 없다.
이 문제를 해결하기 위한 방법은 그래프 캐시(Graph Cache)를 사용하는 것이다. GraphQL의 응답을 평면 구조의 레코드 집합으로 일반화한 후 각 레코드에 전역 고유 ID를 부여하면 전체 응답이 아닌 개별 레코드를 캐싱할 수 있다.
하지만 이 처리가 쉽지 않다. 다른 레코드를 참조하는 레코드가 있으면 순환 그래프를 관리해야 한다. 또한, 캐시를 생성하고 읽으려면 쿼리 구조를 구성해서 읽어야 하며 이를 위해선 별도의 계층을 만들어서 처리해야 할 수도 있다. 하지만 이 방법이 응답 기반 캐시보다 훨씬 효율적이다.

GraphQL을 사용하면서 겪게 될 또 다른 문제는 N+1 SQL 쿼리다. GraphQL 쿼리 필드는 독립형 함수로 설계돼 있으며, 이 필드들을 데이터베이스의 데이터와 연계하기 위해서 새로운 데이터베이스 요청을 만들어야 할 수도 있다. 단순한 REST API 엔드포인트 로직은 SQL 쿼리를 개선하므로 쉽게 N+1 문제를 분석하고 해결할 수 있다. 하지만 필드를 동적으로 연계하는 GraphQL에선 그렇게 쉽게 해결할 수 있는 문제가 아니다.

데이터 로딩 최적화 문제를 위한 해결책으로 페이스북에서 데이터로더(DataLoader)라는 툴을 제시했다. 데이터로더는 데이터를 읽어 GraphQL의 리졸버 함수가 사용할 수 있게 준비해주는 유틸리티이다. 데이터베이스에 SQL 쿼리를 사용해서 데이터를 직접 요청하는 대신 데이터로더를 통해 읽는 것이다. 데이터로더는 중개인으로서 데이터베이스로 보내는 SQL 쿼리를 줄여준다.
데이터로더는 일과 처리(Batch)와 캐시를 조합해서 문제를 처리한다. 데이터베이스에 여러 가지를 요구할 때는 데이터로더가 요청 내용을 통합해 한 번의 클라이언트 요청으로 데이터베이스의 데이터를 일괄적으로 불러온다. 또한, 데이터베이스의 응답을 캐시해두었다가 동일 리소스에 대한 요청이 들어오면 사용한다.

SQL 최적화를 다른 방법으로 사용할 수도 있다. 예플 들어 GraphQL 요청을 분석해서 Join 기반 SQL 쿼리를 구성하는 방법이 있다. 테이블을 Join 하거나 이전 쿼리를 재사용하기 위해 관계형 데이터베이스를 사용하고 있다면, ID 기반 일괄 처리보다 Join 기반 접근법이 나을 수 있다. 단, ID 기반 일괄 처리가 구현하기는 훨씬 쉽다.

### 1.3.3 학습 곡선
GraphQL은 다른 대체 기술보다 학슨 난도가 높다. GraphQL의 API 문법을 알아야 하며 스키마와 리졸버에 대해 이해하고 GraphQL 런타임의 다른 개념들도 알아야 한다.

REST API에서는 이런 문제가 적다. 클라이언트 언어나 표준화된 구현 방법을 필요로 하지 않기 때문이다. 특정 언어로 된 텍스트를 검증하거나 실행할 필요가 없어서 자유롭게 REST 엔드포인트를 수정할 수 있다.

# 2. GraphQL API
## 2.1 그래피컬 편집기
GraphQL에는 브라우저 기반의 툴인 그래피컬(GraphiQL, QL 앞에 i가 있어서 그래피컬 graphical로 발음한다)이 있다.

[https://graphql.org/swapi-graphql][2]

그래피컬 편집기는 GraphQL 타입 스키마를 인식해서 구문의 일부를 입력하면 자동으로 나머지 부분을 완성해준다. 하나의 큰 쿼리를 서버에 던지면 서버가 제공하는 모든 정보를 알 수 있다.

문맥 인식 기능의 유용함은 단순히 타이핑 양이 줄어들어서가 아니라, 유효성이나 검색성 측면에서 더 빠르고 안정적이기 때문이다. 이것이 GraphQL이 다른 기술과 차별되는 장점이다.

GraphQL 쿼리의 오류 응답도 일반적인 JSON 응답(200-OK) 이다. 두 개의 상위 레벨에는 errors 속성)에러 객체의 배열)과 data 속성(빈 응답)이 있다. GraphQL의 응답은 부분적으로 데이터를 표시할 수 있다. 즉, 데이터 중 일부에 오류가 있다면 오류가 없는 부분을 정상적으로 출력한다. 이런 구조는 오류 처리를 ㅜ십게 할 수 있게 도와주며, 응답을 예측할 수 있게 해준다.

## 2.2 기초 GraphQL 언어
GraphQL 서버에 데이터를 요청할 때는 GraphQL 쿼리 언어로 작성된 요청을 보낸다. 그리고 이 요청에는 트리형 필드(field)가 포함된다.

### 2.2.1 요청
GraphQL 커뮤니케이션의 핵심은 요청 객체이다. GraphQL 요청은 문서(document)라고도 불린다. 문서는 쿼리, 변경, 구독 같은 작업 요청을 텍스트로 가지고 있다.

GraphQL 요청에는 변수의 값을 나타내는 객체도 포함되며, 처리와 고나련된 메타 정보(meta-information)도 포함될 수 있다.

GraphQL에서는 세 가지 종류의 작업을 사용할 수 있다.
- Query: 읽기 전용으로 데이터를 추출한다
- Mutation: 데이터를 변경한 후 추출한다.
- Subscription: 실시간으로 데이터 변경 내용을 받는다.

Subscripton 작업은 서버의 정보가 변경될 때마다 GraphQL 서버가 소켓을 열어서 클라이언트의 연결을 허용하고 응답을 반환하도록 요청한다. 이 기능은 UI 뷰가 최신 상태를 유지하도록 지속적으로 데이터를 폴링(polling) 하는 것보다 훨씬 효율적이다.

### 2.2.2 필드
GraphQL의 작업은 객체의 필드를 선택하는 일이라 할 수 있다.

필드는 추출해야 할 객체의 개별 정보 단위를 기술한 것이다.
필드는 스칼라값이나 객체, 객체의 리스트를 기술할 수 있다.

스칼라 타입은 기본 리프(leaf) 값을 나타내며 GraphQL 스키마에선 Int, String, Float, Boolean을 지원한다.
p70

[2]:	https://graphql.org/swapi-graphql